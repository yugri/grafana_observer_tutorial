name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  PYTHON_VERSION: "3.13"
  UV_VERSION: "0.8.0"

# Add permissions for the entire workflow
permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

jobs:
  # Code Quality & Security
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install UV
      uses: astral-sh/setup-uv@v6.4.1
      with:
        version: ${{ env.UV_VERSION }}

    - name: Install dependencies
      run: |
        uv sync --dev

    - name: Install pre-commit
      run: |
        uv run pip install pre-commit

    - name: Install detect-secrets
      run: |
        uv run pip install detect-secrets

    - name: Run pre-commit hooks
      run: |
        uv run pre-commit run --all-files

    - name: Run security scan
      run: |
        uv run detect-secrets scan . --baseline .secrets.baseline

    - name: Run bandit security check
      run: |
        uv run bandit -r . -f json -o bandit-report.json || true
        if [ -f bandit-report.json ]; then
          echo "Security scan completed. Check bandit-report.json for details."
        fi

  # Unit Tests
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install UV
      uses: astral-sh/setup-uv@v6.4.1
      with:
        version: ${{ env.UV_VERSION }}

    - name: Install all dependencies
      run: |
        uv sync --dev
        uv run pip install fastapi uvicorn prometheus-client python-dotenv aiohttp requests httpx

    - name: Install pytest
      run: |
        uv run pip install pytest

    - name: Run tests
      run: |
        uv run pytest tests/ -v --tb=short

    - name: Test imports
      run: |
        # Test that all modules can be imported
        uv run python -c "
        import main
        import load_test
        import explore_metrics
        print('âœ… All modules import successfully')
        "

  # Docker Build & Test
  docker:
    name: Docker Build & Test
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: |
        docker build -t observer-app:test .

    - name: Test Docker image
      run: |
        # Test that the image can start
        docker run --rm -d --name test-app -p 8000:8000 observer-app:test
        sleep 10

        # Test health endpoint
        curl -f http://localhost:8000/health || exit 1

        # Test metrics endpoint
        curl -f http://localhost:8000/metrics || exit 1

        # Cleanup
        docker stop test-app

  # Integration Tests
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: docker

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install UV
      uses: astral-sh/setup-uv@v6.4.1
      with:
        version: ${{ env.UV_VERSION }}

    - name: Install dependencies
      run: |
        uv sync --dev
        uv run pip install aiohttp requests

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Start services
      run: |
        docker compose up -d --build
        sleep 30  # Wait for services to be ready

    - name: Test application health
      run: |
        # Test FastAPI app
        curl -f http://localhost:8000/health || exit 1

        # Test Prometheus
        curl -f http://localhost:9090/api/v1/targets || exit 1

        # Test Grafana
        curl -f -u admin:admin http://localhost:3000/api/health || exit 1

    - name: Test metrics collection
      run: |
        # Generate some load
        uv run python load_test.py --mode normal --duration 10 --url http://localhost:8000

        # Check that metrics are being collected
        sleep 5
        curl -f "http://localhost:9090/api/v1/query?query=http_requests_total" || exit 1

    - name: Cleanup
      if: always()
      run: |
        docker compose down -v

  # Documentation Check
  docs:
    name: Documentation Check
    runs-on: ubuntu-latest
    needs: integration

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check README links
      run: |
        # Check if all referenced files exist
        grep -o '\[.*\]([^)]*)' README.md | sed 's/.*(\([^)]*\))/\1/' | while read link; do
          if [[ $link == http* ]]; then
            echo "External link: $link"
          elif [[ $link == \#* ]]; then
            echo "Anchor link: $link"
          elif [[ -f "$link" ]]; then
            echo "âœ… File exists: $link"
          else
            echo "âŒ Missing file: $link"
            exit 1
          fi
        done

    - name: Check tutorial links
      run: |
        # Check if all referenced files exist
        grep -o '\[.*\]([^)]*)' TUTORIAL.md | sed 's/.*(\([^)]*\))/\1/' | while read link; do
          if [[ $link == http* ]]; then
            echo "External link: $link"
          elif [[ $link == \#* ]]; then
            echo "Anchor link: $link"
          elif [[ -f "$link" ]]; then
            echo "âœ… File exists: $link"
          else
            echo "âŒ Missing file: $link"
            exit 1
          fi
        done

    - name: Validate YAML files
      run: |
        # Check Docker Compose
        docker compose config

        # Check Prometheus config
        python -c "
        import yaml
        with open('prometheus.yml', 'r') as f:
            yaml.safe_load(f)
        print('âœ… prometheus.yml is valid YAML')
        "

        # Check alerts
        python -c "
        import yaml
        with open('prometheus/alerts.yml', 'r') as f:
            yaml.safe_load(f)
        print('âœ… alerts.yml is valid YAML')
        "

  # Release (only on main branch)
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [code-quality, test, docker, integration, docs]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version
      id: get_version
      run: |
        VERSION=$(cat .version)
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Check if tag exists
      id: check_tag
      run: |
        VERSION=$(cat .version)
        if git tag -l "v$VERSION" | grep -q "v$VERSION"; then
          echo "tag_exists=true" >> $GITHUB_OUTPUT
          echo "Tag v$VERSION already exists, skipping release"
        else
          echo "tag_exists=false" >> $GITHUB_OUTPUT
          echo "Tag v$VERSION does not exist, proceeding with release"
        fi

    - name: Generate release notes
      id: release_notes
      if: steps.check_tag.outputs.tag_exists == 'false'
      run: |
        # Get the previous tag or use initial commit
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        if [ -z "$PREVIOUS_TAG" ]; then
          # First release - get all commits
          COMMITS=$(git log --pretty=format:"%s" --reverse)
        else
          # Get commits since last tag
          COMMITS=$(git log --pretty=format:"%s" ${PREVIOUS_TAG}..HEAD)
        fi

        # Initialize sections
        FEATURES=""
        FIXES=""
        BREAKING=""
        DOCS=""
        CHORE=""
        OTHER=""

        # Process each commit
        while IFS= read -r commit; do
          # Skip empty lines
          [ -z "$commit" ] && continue

          # Parse conventional commit format
          if [[ $commit =~ ^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: ]]; then
            TYPE=$(echo "$commit" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:.*/\1/')
            SCOPE=$(echo "$commit" | sed -nE 's/^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)\(([^)]+)\):.*/\2/p')
            MESSAGE=$(echo "$commit" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?: //')

            # Check for breaking changes
            if [[ $commit == *"BREAKING CHANGE"* ]]; then
              BREAKING="${BREAKING}- **BREAKING**: ${MESSAGE}$(printf '\n')"
            else
              case $TYPE in
                "feat")
                  FEATURES="${FEATURES}- ${MESSAGE}$(printf '\n')"
                  ;;
                "fix")
                  FIXES="${FIXES}- ${MESSAGE}$(printf '\n')"
                  ;;
                "docs")
                  DOCS="${DOCS}- ${MESSAGE}$(printf '\n')"
                  ;;
                "chore"|"ci"|"build")
                  CHORE="${CHORE}- ${MESSAGE}$(printf '\n')"
                  ;;
                *)
                  OTHER="${OTHER}- ${MESSAGE}$(printf '\n')"
                  ;;
              esac
            fi
          else
            # Non-conventional commit
            OTHER="${OTHER}- ${commit}$(printf '\n')"
          fi
        done <<< "$COMMITS"

        # Build release body
        RELEASE_BODY="## ðŸš€ Release v${{ steps.get_version.outputs.version }}"

        if [ -n "$BREAKING" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### âš ï¸ Breaking Changes$(printf '\n')${BREAKING}"
        fi

        if [ -n "$FEATURES" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### âœ¨ New Features$(printf '\n')${FEATURES}"
        fi

        if [ -n "$FIXES" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### ðŸ› Bug Fixes$(printf '\n')${FIXES}"
        fi

        if [ -n "$DOCS" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### ðŸ“š Documentation$(printf '\n')${DOCS}"
        fi

        if [ -n "$CHORE" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### ðŸ”§ Maintenance$(printf '\n')${CHORE}"
        fi

        if [ -n "$OTHER" ]; then
          RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### ðŸ“ Other Changes$(printf '\n')${OTHER}"
        fi

        # Add standard sections
        RELEASE_BODY="${RELEASE_BODY}$(printf '\n\n')### ðŸš€ Quick Start$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}\`\`\`bash$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}git clone https://github.com/yugri/grafana_observer_tutorial.git$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}cd grafana_observer_tutorial$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}./start.sh$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}\`\`\`$(printf '\n\n')"
        RELEASE_BODY="${RELEASE_BODY}### ðŸŒ Access Points$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- **Application**: http://localhost:8000$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- **Prometheus**: http://localhost:9090$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- **Grafana**: http://localhost:3000 (admin/admin)$(printf '\n\n')"
        RELEASE_BODY="${RELEASE_BODY}### ðŸ“– Documentation$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- [README.md](README.md) - Project overview and quick start$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- [TUTORIAL.md](TUTORIAL.md) - Detailed learning guide$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}- [SECURITY.md](SECURITY.md) - Security information$(printf '\n\n')"
        RELEASE_BODY="${RELEASE_BODY}---$(printf '\n')"
        RELEASE_BODY="${RELEASE_BODY}*This release was automatically generated based on conventional commits.*"

        # Output the release body using multiline syntax
        echo "release_body<<EOF" >> $GITHUB_OUTPUT
        echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push tag
      if: steps.check_tag.outputs.tag_exists == 'false'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag -a v${{ steps.get_version.outputs.version }} -m "Release v${{ steps.get_version.outputs.version }}"
        git push origin v${{ steps.get_version.outputs.version }}

    - name: Create Release
      if: steps.check_tag.outputs.tag_exists == 'false'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.get_version.outputs.version }}
        release_name: Release v${{ steps.get_version.outputs.version }}
        body: ${{ steps.release_notes.outputs.release_body }}
        draft: false
        prerelease: false

    - name: Update version for next release
      if: steps.check_tag.outputs.tag_exists == 'false'
      run: |
        # Get current version
        CURRENT_VERSION=$(cat .version)
        IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

        # Analyze commits since last tag to determine version bump
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        if [ -z "$PREVIOUS_TAG" ]; then
          # First release - get all commits
          COMMITS=$(git log --pretty=format:"%s" --reverse)
        else
          # Get commits since last tag
          COMMITS=$(git log --pretty=format:"%s" ${PREVIOUS_TAG}..HEAD)
        fi

        # Initialize version bump flags
        MAJOR_BUMP=false
        MINOR_BUMP=false

        # Process each commit to determine version bump
        while IFS= read -r commit; do
          [ -z "$commit" ] && continue

          # Check for breaking changes
          if [[ $commit == *"BREAKING CHANGE"* ]] || [[ $commit =~ ^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)! ]]; then
            MAJOR_BUMP=true
            echo "Found breaking change: $commit"
          elif [[ $commit =~ ^feat(\(.+\))?: ]]; then
            MINOR_BUMP=true
            echo "Found feature: $commit"
          fi
        done <<< "$COMMITS"

        # Determine new version based on semantic versioning
        if [ "$MAJOR_BUMP" = true ]; then
          NEW_MAJOR=$((major + 1))
          NEW_VERSION="$NEW_MAJOR.0.0"
          echo "Major version bump: $CURRENT_VERSION â†’ $NEW_VERSION"
        elif [ "$MINOR_BUMP" = true ]; then
          NEW_MINOR=$((minor + 1))
          NEW_VERSION="$major.$NEW_MINOR.0"
          echo "Minor version bump: $CURRENT_VERSION â†’ $NEW_VERSION"
        else
          NEW_PATCH=$((patch + 1))
          NEW_VERSION="$major.$minor.$NEW_PATCH"
          echo "Patch version bump: $CURRENT_VERSION â†’ $NEW_VERSION"
        fi

        # Update version file
        echo "$NEW_VERSION" > .version

        # Commit and push the version update
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .version
        git commit -m "chore: bump version to $NEW_VERSION for next release"
        git push origin main
